/**  Imports                        ***************************/
import gov.va.vinci.leo.client.DatabaseConnectionInformation
import gov.va.vinci.leo.client.DataQueryInformation
import gov.va.vinci.leo.descriptors.CollectionReaderFactory
import gov.va.vinci.leo.elite.listeners.*
import org.apache.uima.collection.CollectionReader
import gov.va.vinci.leo.model.SimanDataSourceConfiguration
import gov.va.vinci.leo.tools.Common
//import gov.va.vinci.nlp.framework.marshallers.knowtator.KnowtatorListener
/**        End of Imports        ******************************/
/**************************************************************/
/**
 *  Client configuration variables and
 */
/**************************************************************/
/**  Change for each project or each run                      */
/**************************************************************/

String projectDbsName = ""
String projectServer  = ""
String mainPath       = "data/"
String mainOutPath    = mainPath + "output/"
String mainInPath     = mainPath + "input/"

// Reader options
// Available readers: files, database.mySql, database.vinci, knowtator
def readerOptions = [
	files:[
		/* Path to the directory with files. Change the variable below to a full path to the directory with files
		 * relative path:    data/input/
		 * absolute path:    P:/ORD_..../NLP/input/
		 */
		inPath: mainInPath,
		//  inPath : "data/input/",
		//  if you want to limit processing to only top level directory then change to false
		getFilesFromSubdirectories: false
	] ,
	database :[
		/* Only if running MySQL database, which will be local and not VINCI
		 * Settings to use mySQL database: */
		mySql:[
			query : "",
			schema: ""
		],
		/* Settings to read in the data from a Vinci dataset */
		vinci :[
			dbServer : projectServer,
			dbName   : projectDbsName,
			query: "SELECT TIUDocumentSID, reporttext, RowNo   FROM  [***ORD***].[Src].[TIUDocumentSID] where RowNo > {min} and RowNo <= {max};"
			,
			batchSize:10000,
			startId:  1,
			endId:   100
		]
	],
	knowtator: [
		inKttrPath: mainPath,
		kttpTypesMap:["Unknown": "gov.va.vinci.example.types.Term"
		]
	]
]

// Listener options
// Available listeners: simple, knowtator, csv, xmi,
//              database.vinci, database.siman, compare

def listenerOptions=[
	simple :[
		//outPath: mainOutPath + "{suffix}/termTable.csv",
		outPath: mainOutPath + "test/termTable.csv",
		outTypes: "gov.va.vinci.example.types.Term"
	],
	knowtator :[
		outPath: mainOutPath,
		outTypes: "gov.va.vinci.example.types.Term"
	],
	csv : [
		// Absolute or relative path for a new comma-delimited file. If the file exists, it will be overwritten.
		// if the path does not exist, it will be created.
		//outPath : mainOutPath + "{suffix}/outputTable.csv",
		outPath : mainOutPath + "outputTable.csv",
		fieldList : [
			["TIUDocumentSID", "0", "bigint"],
			["Term", "-1", "varchar(1000)"],
			//["Snippets", "-1", "varchar(1000)"],
			//["SpanStart", "-1", "int"],
			//["SpanEnd", "-1", "int"],
			//["InstanceID", "-1", "int"]
		]
	],
	xmi : [
		/* Full path for a new xmi output files. These files can be viewed with UIMA viewer.
		 *   If xmi files exist, they will be overwritten.
		 *   If the path does not exist, it will be created.  */
		outPath : mainOutPath + "{suffix}/xmi/" ,
		outPath : mainOutPath + "test/xmi/" ,
		outputAnnotationType:"",
		openViewerAfterProcessing: false ] ,
	database : [
		mySql : [ // MySql is going to be a very rare case
			dbName : "",
			tableName : "" ],
		// Database variables for output to a VINCI database.
		vinci :[
			dbServer : projectServer, // vhacdwrb01, vhacdwdbs04
			dbName : projectDbsName,
			dbSchema : "dflt", // unless you create your own schema, "dflt" should be used
			tableName : "outTable_{suffix}" , // outTable_{suffix}  , if you add {suffix} to the table name, it will be replaced with time stamp, so that the table does not get ovewritten
			batchSize: 1000,
			fieldList : [
				["TIUDocumentSID", "0", "bigint"],
				["Term", "-1", "varchar(1000)"],
				["Snippets", "-1", "varchar(1000)"],
				["SpanStart", "-1", "int"],
				["SpanEnd", "-1", "int"],
				["InstanceID", "-1", "int"]
				]
		],
		// Siman output is for Chex
		siman : [
			simanSchema : "nlp" , //
			simanSuffix : "_test", // Change the suffix for each run, otherwise the data WILL BE OVERWRITTEN!
			simanTypes: [],  // when blank, SimanListener outputs all annotations
			simanOverwrite : true
		]
	],
// AuCompare -- not setup yet
	compare : [
		typeMap = "{\"gov.va.vinci.example.types.RefStOrganism\":\"gov.va.vinci.example.types.Logic\", " +
		"\"gov.va.vinci.example.types.RefStPositive\":\"gov.va.vinci.example.types.Logic\"," +
		" \"gov.va.vinci.example.types.RefStNegative\":\"gov.va.vinci.example.types.Logic\"}"
	]
]


/**************************************************************/
/**  Users - Do not change code below
 *   Developers - adjust listeners and readers                */
/**************************************************************/
/**
 * Common variables
 */
String sqlDriver = "com.microsoft.sqlserver.jdbc.SQLServerDriver"

// jdbc:sqlserver://VHACDWrb01:1433;databasename=***ORD***;integratedSecurity=true
def sqlUrl = {server, dbsName ->
	"jdbc:sqlserver://" + server+":1433;databasename="+dbsName+";integratedSecurity=true"
}
def createDbi = { server, dbsName ->
	DatabaseConnectionInformation dbConInfo =
			new DatabaseConnectionInformation(
			sqlDriver, sqlUrl.call(server, dbsName), "", "")
	return dbConInfo
}

/**
 * Create Listeners
 */
// Simple annotation listener outputs Span and other features of the specified type
def createSimpleAnnotationListener={ fName, outTypes ->
	File outFile = new File(fName)
	if(!(outFile.getParentFile().exists())) outFile.getParentFile().mkdirs()
	listener = new SimpleAnnotationListener(outFile, outTypes, false)
	return listener
}

/*
 def createAuCompareCsvListener={fName, map  ->
 listener = new AuCompareListener(map, new File(fName))
 //listener.writeHeaders();
 //	String map = listenerOptions."compare"."typeMap"
 }
 */


//
// TODO -- INFO: Starting listener declaration`
def createXmlListener = { xmiDir, outTypeName, openViewer ->
	if(!(new File(xmiDir)).exists()) (new File(xmiDir)).mkdirs()
	listener = new XmiUABListener(new File(xmiDir))
	listener.setLaunchAnnotationViewer(openViewer)
	if(!outTypeName.equals("")) {
		listener.setAnnotationTypeFilter(outTypeName)
	}
	return listener
}

def createCsvListener = {String csvFile, fieldList ->
	if(!(new File(csvFile)).getParentFile().exists()) (new File(csvFile)).getParentFile().mkdirs()
	csvListener = CsvListener_2.createNewListener(csvFile, fieldList)
	csvListener.writeHeaders()
	return csvListener
}

// TODO: Deselect if needed
/*
 def createKnowtatorListener={String outPath, typeList ->
 if(!(new File(outPath)).exists()) {
 (new File(outPath)).mkdirs()
 }
 KnowtatorListener knlistener = new KnowtatorListener("total", "project", outPath, typeList)
 return knlistener
 }
 */

// Database listener
def createDbsListener={ serverName, dbsName, tableName, batchSize, fieldList  ->
	DatabaseConnectionInformation dbConInfo = createDbi.call(projectServer, dbsName)
	dbsListener = DbsListener.createNewListener(dbConInfo, dbsName, tableName, batchSize, fieldList)
	dbsListener.createTable(dbConInfo, dbsListener.createStatement, false, tableName)
	return dbsListener
}

// Simman Listener
def createSimanListener = { serverName, dbsName, schema, tableSuffix, types, boolean overwrite ->
	DatabaseConnectionInformation dbConInfo = createDbi.call(serverName, dbsName)
	String documentTextSelectQuery = ""
	String columnPrefix = "["
	String columnSuffix ="]"
	int batchSize = 1000
	boolean deleteIfExists = overwrite

	simanDataSourceConfiguration = new SimanDataSourceConfiguration(dbConInfo,
			documentTextSelectQuery, schema, tableSuffix,  columnPrefix, columnSuffix)

	dbsListener =  new SimanListener(simanDataSourceConfiguration,
			(String[])types, batchSize, deleteIfExists)
	return dbsListener
}

/**
 * Readers
 */
// TODO -- INFO:  Starting reader declaration
def createFileReader = { inDir ->
	collectionReader = CollectionReaderFactory.generateFileSubReader( new File(inDir),
			"UTF-8", false, "gov.va.vinci.leo.tools.AsciiFilter",
			"gov.va.vinci.leo.tools.XmlFilter")
	return collectionReader
}

// TODO: need to test MySql reader.
def createMySqlBatchReader = { query, indexID, indexText, start, end, batch ->
	DatabaseConnectionInformation dbConInfo = new DatabaseConnectionInformation(
			"com.mysql.jdbc.Driver", "jdbc:mysql://localhost:3306/test", "", "")
	DataQueryInformation dbQInfo = new DataQueryInformation(query, indexText, indexID)
	collectionReader = CollectionReaderFactory.generateBatchDatabaseSubReader(dbConInfo, dbQInfo, start, end, batch); return collectionReader
}

def createVinciBatchReader = { server, dbsName, query,  indexID, indexText, start, end, batch ->
	DatabaseConnectionInformation dbConInfo = createDbi.call(server, dbsName)
	DataQueryInformation dbQInfo = new DataQueryInformation(query, indexText, indexID)
	collectionReader = CollectionReaderFactory.generateBatchDatabaseSubReader(dbConInfo,
			dbQInfo, start, end, batch)
	return collectionReader
}

def createVinciKttrDbReader = { mapObject, serverName, dbsName, query, kttrDir ->
	HashMap<String, String> knowtatorTypeUimaTypeMap = new HashMap<String, String>()
	for(Map.Entry entry: mapObject)
	{
		knowtatorTypeUimaTypeMap.put(entry.key, entry.value)
	}
	collectionReader = CollectionReaderFactory.generateDatabaseAndKnowtatorSubReader(
			createDbi.call(serverName, dbsName),
			new DataQueryInformation(query, 1, 0),
			new File (kttrDir), knowtatorTypeUimaTypeMap, true, "gov.va.vinci.leo.tools.AsciiFilter",
			"gov.va.vinci.leo.tools.XmlFilter")
	return collectionReader
}

def createVinciKttrFileReader = { mapObject,  kttrDir, fileDir ->
	HashMap<String, String> knowtatorTypeUimaTypeMap = new HashMap<String, String>()
	for(Map.Entry entry: mapObject)
	{
		knowtatorTypeUimaTypeMap.put(entry.key, entry.value)
	}

	collectionReader = CollectionReaderFactory.generateKnowtatorFileSubReader(
			new File(fileDir), new File(kttrDir), "UTF-8",
			false, knowtatorTypeUimaTypeMap,
			true, "gov.va.vinci.leo.tools.AsciiFilter",
			"gov.va.vinci.leo.tools.XmlFilter")
	return collectionReader
}

def getTimeStamp = {
	return Common.getTimestampDateDotTime().replaceAll("[.]", "_")
}

/**
 * environments
 */

environments {

	// TODO -- INFO:  simple - read in from file, output to XMIs
	// Simple reader reads in from a set of files
	// and outputs to SimpleListener and XmiUABListener
	simple{
		// reader options

		String inFilePath = readerOptions."files"."inPath"
    System.out.println("Input path " + (new File(inFilePath)).getAbsolutePath());
		CollectionReader collectionReader = createFileReader.call(inFilePath)

		// listener options
		def timeStamp =  getTimeStamp.call()
		String xmiDir = (listenerOptions."xmi"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		String outTypeName = listenerOptions."xmi"."outputAnnotationType"
		boolean openViewer = listenerOptions."xmi"."openViewerAfterProcessing"
		XmiUABListener xmiListener = createXmlListener.call(xmiDir, outTypeName, openViewer)

		def types = (listenerOptions."simple"."outTypes")
		SimpleAnnotationListener sal = createSimpleAnnotationListener.call(
				(listenerOptions."simple"."outPath").replaceAll("\\{suffix\\}", timeStamp), types)

		listeners = [sal, xmiListener]
	}

	// TODO -- INFO:  localdb - read from MySQL database, write to csv and xmi
	localdb{
		// reader options
		String query = readerOptions."database"."mySql"."query"
		int indexID = 0
		int indexText = 1
		int start = 0
		int end = 10
		int batch = 20
		CollectionReader collectionReader = createMySqlBatchReader.call(query, indexID, indexText, start, end, batch)

		// listener options
		def timeStamp =  getTimeStamp.call()
		String xmiDir = (listenerOptions."xmi"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		String outTypeName = listenerOptions."xmi"."outputAnnotationType"
		boolean openViewer = listenerOptions."xmi"."openViewerAfterProcessing"
		XmiUABListener xmiListener = createXmlListener.call(xmiDir, outTypeName, openViewer)

		String csvFile = (listenerOptions."csv"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		CsvListener_2 csvListener = createCsvListener.call(csvFile )

		listeners = [xmiListener, csvListener]
	}

	// TODO -- INFO:vinciDbToCsv - read from MS SQL Server on Vinci and write to csv and xmi
	vinciDbToCsv{
		// Reader options
		String query  = readerOptions."database"."vinci"."query"
		int indexID = 0   // always keep index as the first field
		int indexText = 1 // always keep text as the second field
		int start = readerOptions."database"."vinci"."startId"
		int end   = readerOptions."database"."vinci"."endId"
		int batch = readerOptions."database"."vinci"."batchSize" // always keep batch size as 10000
		String dbsName = readerOptions."database"."vinci"."dbName"
		String server = readerOptions."database"."vinci"."dbServer"
		CollectionReader collectionReader = createVinciBatchReader.call(server, dbsName, query,
				indexID, indexText, start, end, batch)

		// listener options
		def timeStamp =  getTimeStamp.call()
		//	String xmiDir = (listenerOptions."xmi"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		//	String outTypeName = listenerOptions."xmi"."outputAnnotationType"
		//boolean openViewer = listenerOptions."xmi"."openViewerAfterProcessing"
		//XmiUABListener xmiListener = createXmlListener.call(xmiDir, outTypeName, openViewer)

		String csvFile = (listenerOptions."csv"."outPath").replaceAll("\\{suffix\\}", timeStamp)

		CsvListener_2 csvListener = createCsvListener.call(csvFile, listenerOptions."csv"."fieldList"  )

		//def types = (listenerOptions."simple"."outTypes")
		//SimpleAnnotationListener sal1 = createSimpleAnnotationListener.call((listenerOptions."simple"."outPath").replaceAll("\\{suffix\\}", timeStamp), types)


		listeners = [csvListener]//, sal1, xmiListener]
	}


	// TODO: Is not done
	vinciDbToKnowtator{
		// Reader options
		String query  = readerOptions."database"."vinci"."query"
		int indexID = 0   // always keep index as the first field
		int indexText = 1 // always keep text as the second field
		int start = readerOptions."database"."vinci"."startId"
		int end   = readerOptions."database"."vinci"."endId"
		int batch = readerOptions."database"."vinci"."batchSize" // always keep batch size as 10000
		String dbsName = readerOptions."database"."vinci"."dbName"
		String server = readerOptions."database"."vinci"."dbServer"
		CollectionReader collectionReader = createVinciBatchReader.call(server, dbsName, query,
				indexID, indexText, start, end, batch)
		// listener options
		def timeStamp =  getTimeStamp.call()
		String xmiDir = (listenerOptions."xmi"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		String outTypeName = listenerOptions."xmi"."outputAnnotationType"
		boolean openViewer = listenerOptions."xmi"."openViewerAfterProcessing"
		XmiUABListener xmiListener = createXmlListener.call(xmiDir, outTypeName, openViewer)

		String csvFile = (listenerOptions."csv"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		CsvListener_2 CsvListener = createCsvListener.call(csvFile )

		String knwDir = (listenerOptions."knowtator"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		String outtypes = listenerOptions."knowtator"."outTypes"
		//	KnowtatorListener knlistener = createKnowtatorListener.call(knwDir, outtypes)

		listeners = [CsvListener]//, knlistener]
	}

	// TODO -- INFO: vinciDbToDb - reading from Database and writing to database
	vinciDbToDb{
		// reader
		String query  = readerOptions."database"."vinci"."query"
		int indexID = 0   // always keep index as the first field
		int indexText = 1 // always keep text as the second field
		int start = readerOptions."database"."vinci"."startId"
		int end   = readerOptions."database"."vinci"."endId"
		int batch = 1000000 // always keep batch size as 10000
		String dbsName = readerOptions."database"."vinci"."dbName"
		String inServer = readerOptions."database"."vinci"."dbServer"
		CollectionReader collectionReader = createVinciBatchReader.call(inServer, dbsName, query,
				indexID, indexText, start, end, batch)

		// listeners
		def timeStamp =  getTimeStamp.call()
		String outServer = listenerOptions."database"."vinci"."dbServer"
		String outDbsName = listenerOptions."database"."vinci"."dbName"
		String tableName = (listenerOptions."database"."vinci"."tableName" ).replaceAll("\\{suffix\\}", timeStamp)
		String outTblName = "["+listenerOptions."database"."vinci"."dbSchema" + "]."+ "[" +tableName + "]"

		DbsListener dbsListener = createDbsListener.call(outServer, outDbsName, outTblName,
			listenerOptions."database"."vinci"."batchSize",
			listenerOptions."database"."vinci"."fieldList" )
		listeners = [dbsListener]
	}

	// TODO -- INFO: vinciDbToDb - reading from Database and writing to database
	vinciKttrFileToCsv{
		String kttrDir = readerOptions."knowtator"."inKttrPath"
		String fileDir = readerOptions."files"."inPath"
		Map kttrMap = readerOptions."knowtator"."kttpTypesMap"

		CollectionReader collectionReader = createVinciKttrFileReader.call(kttrMap, kttrDir, fileDir )
		def timeStamp =  getTimeStamp.call()
		String xmiDir = (listenerOptions."xmi"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		String outTypeName = listenerOptions."xmi"."outputAnnotationType"
		boolean openViewer = listenerOptions."xmi"."openViewerAfterProcessing"
		XmiUABListener xmiListener = createXmlListener.call(xmiDir, outTypeName, openViewer)

		String csvFile = (listenerOptions."csv"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		CsvListener_2 csvListener = createCsvListener.call(csvFile )

		def types = (listenerOptions."simple"."outTypes")
		SimpleAnnotationListener sal1 = createSimpleAnnotationListener.call((listenerOptions."simple"."outPath").replaceAll("\\{suffix\\}", timeStamp), types)

		//AuCompareCsvListener acl = createAuCompareCsvListener((listenerOptions."simple"."outPath")+ "\\" + timeStamp + "\\CompareEF.csv")
		listeners = [csvListener, sal1, xmiListener]
	}

	// TODO -- INFO: vinciDbToDb - reading from Database and writing to database
	vinciKttrDbToDb{
		String dbsName =  readerOptions."database"."vinci"."dbName"
		String serverName = readerOptions."database"."vinci"."dbServer"
		String query = readerOptions."database"."vinci"."query"
		String kttrDir = readerOptions."knowtator"."inKttrPath"
		Map kttrMap = readerOptions."knowtator"."kttpTypesMap"
		CollectionReader collectionReader = createVinciKttrDbReader.call(kttrMap, serverName, dbsName, query, kttrDir)

		def timeStamp =  getTimeStamp.call()
		String outServer = listenerOptions."database"."vinci"."dbServer"
		String outDbsName = listenerOptions."database"."vinci"."dbName"
		String tableName = (listenerOptions."database"."vinci"."tableName" ).replaceAll("\\{suffix\\}", timeStamp)
		String outTblName = "["+listenerOptions."database"."vinci"."dbSchema" + "]."+ "[" +tableName + "]"

		DbsListener dbsListener = createDbsListener.call(outServer, outDbsName, outTblName,
			listenerOptions."database"."vinci"."batchSize",
			listenerOptions."database"."vinci"."fieldList" )

		listeners = [dbsListener]
	}

	// TODO -- INFO: vinciDbToDb - reading from Database and writing to database
	vinciDbToSiman{
		// reader
		String query  = readerOptions."database"."vinci"."query"
		int indexID = 0   // always keep index as the first field
		int indexText = 1 // always keep text as the second field
		int start = readerOptions."database"."vinci"."startId"
		int end   = readerOptions."database"."vinci"."endId"
		int batch = 1000000 // always keep batch size as 10000
		String dbsName = readerOptions."database"."vinci"."dbName"
		String server = readerOptions."database"."vinci"."dbServer"
		CollectionReader collectionReader = createVinciBatchReader.call(server, dbsName, query,
				indexID, indexText, start, end, batch)

		// listeners
		String serverName  = listenerOptions."database"."vinci"."dbServer"
		String schema      = listenerOptions."database"."siman"."simanSchema"
		String simanSuffix = listenerOptions."database"."siman"."simanSuffix"
		String[] types     = listenerOptions."database"."siman"."simanTypes"
		boolean overwrite  = listenerOptions."database"."siman"."simanOverwrite"
		SimanListener dbsSimanListener = createSimanListener.call(serverName, dbsName, schema, simanSuffix, types, overwrite )

		def timeStamp =  getTimeStamp.call()
		String xmiDir = (listenerOptions."xmi"."outPath").replaceAll("\\{suffix\\}", timeStamp)
		String outTypeName = listenerOptions."xmi"."outputAnnotationType"
		boolean openViewer = listenerOptions."xmi"."openViewerAfterProcessing"
		XmiUABListener xmiListener = createXmlListener.call(xmiDir, outTypeName, openViewer)


		listeners = [dbsSimanListener, xmiListener]
	}

}
/// TODO: End of config file
